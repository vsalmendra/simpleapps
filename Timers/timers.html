<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Timers SPA â€” Stopwatch & Countdown</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes blink { 50% { opacity: 0.25; } }
        .blink { animation: blink 1s steps(2, start) infinite; }
        html, body, #root { height: 100%; }
    </style>
</head>
<body class="bg-black text-neutral-200 antialiased">
<div id="root" class="h-full"></div>

<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="text/babel">
    const { useEffect, useRef, useState, useMemo } = React;

    // Utility functions
    const hexToRgb = (hex) => {
        const h = hex.replace('#','');
        const bigint = parseInt(h.length === 3 ? h.split('').map(c=>c+c).join('') : h, 16);
        return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: (bigint >> 0) & 255 };
    };
    const rgbToHex = ({r,g,b}) => '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
    const lerp = (a,b,t) => a + (b-a)*t;
    const lerpColor = (hexA, hexB, t) => {
        const a = hexToRgb(hexA), b = hexToRgb(hexB);
        return rgbToHex({ r: Math.round(lerp(a.r,b.r,t)), g: Math.round(lerp(a.g,b.g,t)), b: Math.round(lerp(a.b,b.b,t)) });
    };

    const COLORS = {
        neutral: '#d4d4d4',
        yellow: '#facc15',
        red: '#ef4444',
        green: '#22c55e', // Tailwind green-500
    };

    // ----------- STUN connectivity indicator hook -------------
    function useStunIndicator() {
        const [status, setStatus] = useState('green');
        const issuesRef = useRef([]);

        useEffect(() => {
            let running = true;
            let waiting = false;
            let timerId;

            function sendStunRequest() {
                if (!running) return;
                if (waiting) return;

                waiting = true;
                const sentAt = Date.now();
                let resolved = false;

                // Use WebRTC to send a STUN packet and measure response time
                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
                });

                let timeoutId = setTimeout(() => {
                    if (!resolved) {
                        recordIssue("timeout");
                        cleanup();
                    }
                }, 3000);

                function recordIssue(type) {
                    const now = Date.now();
                    issuesRef.current.push({ t: now, type });
                }

                function cleanup() {
                    resolved = true;
                    clearTimeout(timeoutId);
                    pc.close();
                    waiting = false;
                }

                pc.onicecandidate = (event) => {
                    if (!event.candidate) return;
                    const now = Date.now();
                    const latency = now - sentAt;
                    if (latency > 80) {
                        recordIssue("high-latency");
                    }
                    cleanup();
                };

                // Start ICE gathering
                pc.createDataChannel("ping");
                pc.createOffer()
                    .then(offer => pc.setLocalDescription(offer))
                    .catch(() => {
                        recordIssue("error");
                        cleanup();
                    });
            }

            function checkIssues() {
                const now = Date.now();
                // Only keep issues within last 60 seconds
                issuesRef.current = issuesRef.current.filter(issue => now - issue.t < 60000);
                const numIssues = issuesRef.current.length;
                if (numIssues > 4) setStatus('red');
                else if (numIssues > 2) setStatus('yellow');
                else setStatus('green');
            }

            function loop() {
                if (!running) return;
                sendStunRequest();
                checkIssues();
                timerId = setTimeout(loop, 1000);
            }
            loop();

            return () => {
                running = false;
                clearTimeout(timerId);
            };
        }, []);

        return status;
    }
    // ----------------------------------------------------------

    function App() {
        // Existing stopwatch & countdown code
        const [swRunning, setSwRunning] = useState(false);
        const [swElapsed, setSwElapsed] = useState(0);
        const swStartRef = useRef(0);
        const swRafRef = useRef(0);

        const tickStopwatch = () => {
            setSwElapsed(Date.now() - swStartRef.current);
            swRafRef.current = requestAnimationFrame(tickStopwatch);
        };

        const startStopwatch = () => {
            if (swRunning) return;
            setSwRunning(true);
            swStartRef.current = Date.now() - swElapsed;
            swRafRef.current = requestAnimationFrame(tickStopwatch);
        };
        const stopStopwatch = () => {
            setSwRunning(false);
            cancelAnimationFrame(swRafRef.current);
        };
        const resetStopwatch = () => {
            cancelAnimationFrame(swRafRef.current);
            setSwRunning(false);
            setSwElapsed(0);
        };
        const restartStopwatch = () => {
            swStartRef.current = Date.now();
            setSwElapsed(0);
            if (!swRunning) {
                setSwRunning(true);
                swRafRef.current = requestAnimationFrame(tickStopwatch);
            }
        };

        const thresholdStartMs = 10 * 60 * 1000;
        const thresholdEndMs = 15 * 60 * 1000;
        const swColor = useMemo(() => {
            if (swElapsed >= thresholdEndMs) return COLORS.red;
            if (swElapsed <= thresholdStartMs) return COLORS.neutral;
            const t = Math.min(1, (swElapsed - thresholdStartMs) / (thresholdEndMs - thresholdStartMs));
            return lerpColor(COLORS.neutral, COLORS.yellow, t);
        }, [swElapsed]);

        const [cdInputs, setCdInputs] = useState({ h: "0", m: "1", s: "0" });
        const [cdInitialMs, setCdInitialMs] = useState(60_000);
        const [cdRemaining, setCdRemaining] = useState(60_000);
        const [cdRunning, setCdRunning] = useState(false);
        const [cdExpired, setCdExpired] = useState(false);
        const cdStartRef = useRef(0);
        const cdRafRef = useRef(0);

        const computeCdMs = (h, m, s) => {
            const hh = Math.max(0, parseInt(h || "0", 10) || 0);
            const mm = Math.max(0, parseInt(m || "0", 10) || 0);
            const ss = Math.max(0, parseInt(s || "0", 10) || 0);
            return (hh * 3600 + mm * 60 + ss) * 1000;
        };

        const setCountdownValue = () => {
            const ms = computeCdMs(cdInputs.h, cdInputs.m, cdInputs.s);
            setCdInitialMs(ms);
            setCdRemaining(ms);
            setCdExpired(ms === 0);
        };

        const tickCountdown = () => {
            const elapsed = Date.now() - cdStartRef.current;
            setCdRemaining(() => {
                const next = Math.max(0, cdInitialMs - elapsed);
                return next;
            });
            if (cdInitialMs - elapsed <= 0) {
                setCdRunning(false);
                setCdExpired(true);
                cancelAnimationFrame(cdRafRef.current);
                return;
            }
            cdRafRef.current = requestAnimationFrame(tickCountdown);
        };

        const startCountdown = () => {
            if (cdRunning) return;
            if (cdRemaining <= 0) {
                setCdRemaining(cdInitialMs);
                setCdExpired(false);
            }
            setCdRunning(true);
            cdStartRef.current = Date.now() - (cdInitialMs - cdRemaining);
            cdRafRef.current = requestAnimationFrame(tickCountdown);
        };
        const stopCountdown = () => {
            setCdRunning(false);
            cancelAnimationFrame(cdRafRef.current);
        };
        const resetCountdown = () => {
            cancelAnimationFrame(cdRafRef.current);
            setCdRunning(false);
            setCdRemaining(cdInitialMs);
            setCdExpired(cdInitialMs === 0);
        };

        useEffect(() => () => {
            cancelAnimationFrame(swRafRef.current);
            cancelAnimationFrame(cdRafRef.current);
        }, []);

        const pad2 = (n) => String(n).padStart(2, "0");
        const fmtMMSS = (ms) => {
            const total = Math.floor(ms / 1000);
            const mm = Math.floor(total / 60);
            const ss = total % 60;
            return `${pad2(mm)}:${pad2(ss)}`;
        };
        const fmtHHMMSS = (ms) => {
            const total = Math.floor(ms / 1000);
            const hh = Math.floor(total / 3600);
            const mm = Math.floor((total % 3600) / 60);
            const ss = total % 60;
            return `${pad2(hh)}:${pad2(mm)}:${pad2(ss)}`;
        };

        const cdColor = useMemo(() => {
            if (cdInitialMs <= 0) return COLORS.neutral;
            const threshold = cdInitialMs * 0.2;
            if (cdRemaining >= threshold) return COLORS.neutral;
            const t = 1 - Math.max(0, cdRemaining) / threshold;
            return lerpColor(COLORS.neutral, COLORS.yellow, t);
        }, [cdRemaining, cdInitialMs]);

        const numberBaseClass = "font-mono tracking-tight select-none drop-shadow-sm";
        const btn = "px-3 py-2 rounded-xl bg-neutral-800 text-neutral-200 border border-neutral-700 hover:bg-neutral-700 transition disabled:opacity-50 disabled:cursor-not-allowed";
        const btnGreen = "px-3 py-2 rounded-xl bg-green-700 text-neutral-100 border border-green-800 hover:bg-green-600 transition disabled:opacity-50 disabled:cursor-not-allowed";
        const btnRed = "px-3 py-2 rounded-xl bg-red-700 text-neutral-100 border border-red-800 hover:bg-red-600 transition disabled:opacity-50 disabled:cursor-not-allowed";
        const field = "w-16 px-2 py-2 rounded-lg bg-neutral-900 text-neutral-100 border border-neutral-800 outline-none text-center";

        // Connectivity indicator logic
        const stunStatus = useStunIndicator();
        const indicatorColor = {
            green: COLORS.green,
            yellow: COLORS.yellow,
            red: COLORS.red,
        }[stunStatus];

        return (
            <div className="h-full w-full flex items-stretch justify-center">
                <main className="w-full md:w-[33vw] max-w-[640px] px-4 md:px-6 py-6 flex flex-col gap-6">
                    <section className="flex-1 rounded-3xl border border-neutral-800 bg-neutral-950 p-4 md:p-6 flex flex-col">
                        <header className="flex items-center justify-between mb-3">
                            <h2 className="text-neutral-300 font-semibold">Countdown</h2>
                            <div className="flex items-center gap-2">
                                <input aria-label="Hours" className={field} inputMode="numeric" value={cdInputs.h} onChange={(e) => setCdInputs((p) => ({ ...p, h: e.target.value.replace(/[^0-9]/g, "") }))} />
                                <span className="text-neutral-600">:</span>
                                <input aria-label="Minutes" className={field} inputMode="numeric" value={cdInputs.m} onChange={(e) => setCdInputs((p) => ({ ...p, m: e.target.value.replace(/[^0-9]/g, "") }))} />
                                <span className="text-neutral-600">:</span>
                                <input aria-label="Seconds" className={field} inputMode="numeric" value={cdInputs.s} onChange={(e) => setCdInputs((p) => ({ ...p, s: e.target.value.replace(/[^0-9]/g, "") }))} />
                                <button className={btn} onClick={setCountdownValue} disabled={cdRunning}>Set</button>
                            </div>
                        </header>
                        <div className="flex-1 flex items-center justify-center">
                            <div className={`${numberBaseClass} ${cdExpired ? "blink" : ""} text-6xl sm:text-7xl md:text-8xl lg:text-9xl`} style={{ color: cdColor }}>{fmtHHMMSS(cdRemaining)}</div>
                        </div>
                        <footer className="mt-3 flex items-center justify-center gap-3">
                            {
                                !cdRunning
                                ? (<button className={btnGreen} onClick={startCountdown}>Start</button>)
                                : (<button className={btnRed} onClick={stopCountdown}>Stop</button>)
                            }
                            <button className={btn} onClick={resetCountdown}>Reset</button>
                        </footer>
                    </section>

                    <section className="flex-1 rounded-3xl border border-neutral-800 bg-neutral-950 p-4 md:p-6 flex flex-col">
                        <header className="flex items-center justify-between mb-3">
                            <h2 className="text-neutral-300 font-semibold">Stopwatch</h2>
                            <div className="text-neutral-500 text-sm">mm:ss</div>
                        </header>
                        <div className="flex-1 flex items-center justify-center">
                            <div className={`${numberBaseClass} text-6xl sm:text-7xl md:text-8xl lg:text-9xl`} style={{ color: swColor }}>{fmtMMSS(swElapsed)}</div>
                        </div>
                        <footer className="mt-3 flex items-center justify-center gap-3">
                            {
                                !swRunning
                                ? (
                                    <>
                                        <button className={btnGreen} onClick={startStopwatch}>Start</button>
                                        <button className={btn} onClick={restartStopwatch}>Restart</button>
                                        <button className={btn} onClick={resetStopwatch}>Reset</button>
                                    </>
                                )
                                : (
                                    <>
                                        <button className={btnRed} onClick={stopStopwatch}>Stop</button>
                                        <button className={btn} onClick={restartStopwatch}>Restart</button>
                                        <button className={btn} onClick={resetStopwatch}>Reset</button>
                                    </>
                                )
                            }
                        </footer>
                    </section>
                </main>
                {/* Connectivity indicator */}
                <div style={{
                    position: "fixed",
                    bottom: "20px",
                    left: 0,
                    width: "100%",
                    display: "flex",
                    justifyContent: "center",
                    pointerEvents: "none",
                    zIndex: 50,
                }}>
                    <span
                        style={{
                            width: "18px",
                            height: "18px",
                            borderRadius: "9999px",
                            background: indicatorColor,
                            border: "2px solid #222",
                            boxShadow: "0 2px 8px rgba(0,0,0,0.2)",
                            display: "inline-block",
                        }}
                        title={
                            stunStatus === "green"
                                ? "Internet connectivity is good"
                                : stunStatus === "yellow"
                                    ? "Some connectivity issues detected"
                                    : "Connectivity issues detected"
                        }
                    />
                </div>
            </div>
        );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
